global function pulseInit
global function GetStatsFromToneAPI
global function getFromToneAPI
global function fetchGamemodeStatsFromToneAPI

global table globalToneAPIKillData = {}
global table globalToneAPIDeathData = {}
global table globalToneAPIDWEData = {}
global table globalToneAPIMapDeathData = {}
global table globalToneAPIMapDistData = {}
global table globalToneAPIMapKillData = {}
global table globalToneAPIMapMDistData = {}
global table globalToneAPIGamemodeData = {}
global table globalToneAPIAllPlayerKillData = {}
global table globalToneAPIAllPlayerDeathData = {}
global table< table > globalToneAPIGamemodeMapData = {}

string prefix = "default"
string HTTPrequestURL = "default"
string currentVersion = "default"
int mapGamemodeEntries = 0

struct {
    array<string> allMaps
} file

void function pulseInit()
{
    prefix = "\x1b[38;2;255;178;102m[PULSE]\x1b[0m "
    HTTPrequestURL = GetConVarString("ToneURL")
    currentVersion = "v" + GetConVarString("MajorVersion") + "." + GetConVarString("MinorVersion") + "." + GetConVarString("PatchVersion")
    HttpRequest getVersion
    getVersion.method = HttpRequestMethod.GET
    getVersion.url = GetConVarString("VersionURL")
    void functionref(HttpRequestResponse) onSuccess = void function(HttpRequestResponse response)
    {
        table JSONDecoded = DecodeJSON(response.body)
        if (JSONDecoded["Major"] == GetConVarString("MajorVersion") && JSONDecoded["Minor"] == GetConVarString("MinorVersion") && JSONDecoded["Patch"] == GetConVarString("PatchVersion")) {
            print(prefix + currentVersion + " has been loaded and is up to date.")
        } else {
            print(prefix + currentVersion + " has been loaded. Recommend updating to latest version: v" + JSONDecoded["Major"] + "." + JSONDecoded["Minor"] + "." + JSONDecoded["Patch"] + ".")
        }
    }
    void functionref(HttpRequestFailure) onFailure = void function(HttpRequestFailure failure)
    {
        print(prefix + currentVersion + " has been loaded and has encountered an error getting latest version data.")
    }
    NSHttpRequest(getVersion, onSuccess, onFailure)
}

void function GetStatsFromToneAPI()
{
    string UID = NSGetLocalPlayerUID()
    array <string> allHttpRequests = ["/weapons", "/weapons", "/maps", "/gamemodes"]
    array <string> allHttpParameters = [UID, "!" + UID, UID, UID]
    for (int i; i < allHttpRequests.len(); i++) {
        HttpRequest getStats
        getStats.method = HttpRequestMethod.GET
        getStats.url = HTTPrequestURL + allHttpRequests[i]
        getStats.queryParameters["player"] <- [allHttpParameters[i]]
        void functionref(HttpRequestResponse) onSuccess = void function(HttpRequestResponse response) : (i, allHttpRequests)
        {
            table DecodedJSON = DecodeJSON(response.body)
            foreach (var key, var value in DecodedJSON) {
                table test = expect table(value)
                switch (i) {
                    case 0:
                        globalToneAPIKillData[string(key)] <- test.kills
                        globalToneAPIDeathData[string(key)] <- test.deaths
                        globalToneAPIDWEData[string(key)] <- test.deaths_while_equipped
                    case 1:
                        globalToneAPIAllPlayerKillData[string(key)] <- test.kills
                        globalToneAPIAllPlayerDeathData[string(key)] <- test.deaths
                    case 2:
                        globalToneAPIMapKillData[string(key)] <- test.kills
                        globalToneAPIMapDeathData[string(key)] <- test.deaths
                        globalToneAPIMapDistData[string(key)] <- test.total_distance
                        globalToneAPIMapMDistData[string(key)] <- test.max_distance
                    case 3:
                        globalToneAPIGamemodeData[string(key)] <- test.kills
                }
            }
            print(prefix + "has succeeded in getting stats for " + allHttpRequests[i].slice(1))
        }
        void functionref(HttpRequestFailure) onFailure = void function(HttpRequestFailure failure) : (i, allHttpRequests)
        {
            print(prefix + "has encountered an error getting stats for " + allHttpRequests[i].slice(1))
        }
        NSHttpRequest(getStats, onSuccess, onFailure)
    }
}

void function fetchGamemodeStatsFromToneAPI(string mapName)
{
    mapGamemodeEntries = 0
    string mapNameSliced = mapName.slice(3)
    HttpRequest getMapGamemodeStats
    getMapGamemodeStats.method = HttpRequestMethod.GET
    getMapGamemodeStats.url = HTTPrequestURL + "/gamemodes"
    getMapGamemodeStats.queryParameters["map"] <- [mapNameSliced]
    getMapGamemodeStats.queryParameters["player"] <- [NSGetLocalPlayerUID()]
    void functionref(HttpRequestResponse) onSuccess = void function(HttpRequestResponse response):(mapName)
    {
        table JSONForConversion = DecodeJSON(response.body)
        table mapData = {}
        foreach (var gamemode, var value in JSONForConversion) {
            table test = expect table(value)
            mapData[string(gamemode)] <- test.kills
            mapGamemodeEntries += 1
        }

        globalToneAPIGamemodeMapData[mapName] <- mapData

        print(prefix + "Map gamemode data has been processed with a total of " + string(mapGamemodeEntries) + " entries.")
    }

    void functionref(HttpRequestFailure) onFailure = void function(HttpRequestFailure failure)
    {
        print(prefix + "Encountered an error getting map gamemode data...")
    }

    NSHttpRequest(getMapGamemodeStats, onSuccess, onFailure)
}

int function getFromToneAPI(string parameter, table data){

    if (file.allMaps.find(parameter) != -1) {
        parameter = parameter.slice(3)
    }
    if (parameter in data) {
        return expect int(data[parameter])
    }
    return 0
}
